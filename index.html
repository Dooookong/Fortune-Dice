<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Fortune Dice</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üé≤</text></svg>">
    <link rel="stylesheet" as="style" crossorigin href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css" />

    <style>
        html, body {
            margin: 0; padding: 0; width: 100%; height: 100%;
            background: #000000;
            overflow: hidden; 
            font-family: 'Pretendard', sans-serif;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; }
        .ui-container { position: absolute; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        .hidden { opacity: 0 !important; pointer-events: none !important; transform: scale(0.95); transition: opacity 0.3s, transform 0.3s; }
        .visible { opacity: 1 !important; pointer-events: auto !important; transform: scale(1); transition: opacity 0.3s, transform 0.3s; }

        /* Î°úÍ≥† ÏòÅÏó≠ */
        .logo-section {
            position: absolute; top: 15%; width: 100%; text-align: center;
            display: flex; flex-direction: column; align-items: center;
            padding: 0 20px; box-sizing: border-box;
        }
        .logo-text {
            font-size: clamp(50px, 15vw, 100px);
            font-weight: 900; line-height: 1.1; color: #fff;
            background: linear-gradient(to bottom right, #a29bfe 20%, #fff 80%);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 25px rgba(108, 92, 231, 0.6));
            letter-spacing: -2px; word-break: keep-all;
        }
        .subtitle {
            font-size: clamp(14px, 4vw, 18px); color: rgba(255,255,255,0.6); 
            font-weight: 300; letter-spacing: 1px; margin-top: 15px;
        }
        .btn-section { position: absolute; bottom: 15%; width: 100%; text-align: center; pointer-events: auto; }

        /* Í≤∞Í≥º ÌôîÎ©¥ */
        #result-ui { 
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            background: rgba(0, 0, 0, 0.7); backdrop-filter: blur(10px); z-index: 20;
        }
        .result-card {
            background: rgba(30, 30, 35, 0.9); border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 40px 30px; border-radius: 30px; text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.8);
            transform: translateY(20px); transition: transform 0.5s;
            pointer-events: auto; width: 80%; max-width: 400px;
        }
        #result-ui.visible .result-card { transform: translateY(0); }
        .score-title { color: #a29bfe; font-size: 18px; margin-bottom: 5px; font-weight: 500; }
        .total-score { color: #fff; font-size: 80px; font-weight: 800; margin: 0 0 30px 0; line-height: 1; }
        
        /* [ÏàòÏ†ï] Í∑∏Î¶¨Îìú Î†àÏù¥ÏïÑÏõÉ Î≥ÄÍ≤Ω: 3Ïó¥ Í≤©Ïûê */
        .dice-grid { 
            display: grid;
            grid-template-columns: repeat(3, 1fr); /* 3Í∞úÏî© ÎÇòÏó¥ */
            gap: 12px; 
            justify-items: center;
            margin: 0 auto 30px auto; 
            max-width: 200px; /* Ï§ëÏïô Ï†ïÎ†¨ÏùÑ ÏúÑÌï¥ Ìè≠ Ï†úÌïú */
        }
        .mini-dice {
            width: 44px; height: 44px; background: #fdfdfd; border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3); padding: 4px; box-sizing: border-box;
            display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr);
        }
        .dot { width: 8px; height: 8px; border-radius: 50%; background-color: #000; align-self: center; justify-self: center; }
        .mini-dice.red .dot { background-color: #d63031; }

        .btn-group { display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; }
        .btn { padding: 16px 40px; border-radius: 100px; border: none; font-size: 16px; font-weight: 700; cursor: pointer; transition: all 0.2s; pointer-events: auto; }
        .btn-primary { background: #6c5ce7; color: white; box-shadow: 0 10px 30px rgba(108, 92, 231, 0.4); }
        .btn-primary:hover { background: #5f4dd0; transform: scale(1.05); }
        .btn-secondary { background: rgba(255,255,255,0.1); color: white; border: 1px solid rgba(255,255,255,0.2); }
        .btn-secondary:hover { background: rgba(255,255,255,0.2); }
        
        #status-msg {
            position: absolute; top: 12%; width: 100%; text-align: center;
            color: rgba(255,255,255,0.8); font-size: 18px; font-weight: 500; 
            opacity: 0; transition: opacity 0.3s; pointer-events: none; z-index: 15;
            padding: 0 20px; box-sizing: border-box;
        }
        #status-msg.show { opacity: 1; }
    </style>
</head>
<body>

<div id="canvas-container"></div>
<div id="status-msg">Ï£ºÏÇ¨ÏúÑÍ∞Ä Î©àÏ∂ú ÎïåÍπåÏßÄ Í∏∞Îã§Î†§Ï£ºÏÑ∏Ïöî...</div>

<div id="home-ui" class="ui-container visible">
    <div class="logo-section">
        <div class="logo-text">Fortune Dice</div>
        <div class="subtitle">Ïò§Îäò ÌïòÎ£®Ïùò Ïö¥ÏÑ∏Î•º ÌôïÏù∏ÌïòÏÑ∏Ïöî.</div>
    </div>
    <div class="btn-section">
        <button class="btn btn-primary" onclick="startGame()">Ï£ºÏÇ¨ÏúÑ Íµ¥Î¶¨Í∏∞</button>
    </div>
</div>

<div id="result-ui" class="ui-container hidden">
    <div class="result-card">
        <div class="score-title">Ïò§ÎäòÏùò Ïö¥ÏÑ∏ Ï†êÏàò</div>
        <div class="total-score" id="totalScore">0Ï†ê</div>
        <div class="dice-grid" id="diceGrid"></div>
        <div class="btn-group">
            <button class="btn btn-secondary" onclick="goHome()">ÌôàÏúºÎ°ú</button>
            <button class="btn btn-primary" onclick="reRoll()">Îã§Ïãú Íµ¥Î¶¨Í∏∞</button>
        </div>
    </div>
</div>

<script type="importmap">
{
    "imports": {
        "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/",
        "cannon-es": "https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/+esm"
    }
}
</script>

<script type="module">
import * as THREE from 'three';
import * as CANNON from 'cannon-es';
import { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js';

let isHomeMode = true;
let isRolling = false;
let stableFrames = 0;

// 1. Scene & World
const scene = new THREE.Scene();
const world = new CANNON.World();
world.gravity.set(0, -40, 0);
world.allowSleep = true;
world.defaultContactMaterial.restitution = 0.3;
world.defaultContactMaterial.friction = 0.2;

const camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 100);
camera.position.set(0, 0, 14); 
camera.lookAt(0, 0, 0);

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.getElementById('canvas-container').appendChild(renderer.domElement);

// 2. Lights & Floor
scene.add(new THREE.AmbientLight(0xffffff, 0.8));
const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
dirLight.position.set(5, 10, 10);
dirLight.castShadow = true;
scene.add(dirLight);

const floorMat = new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0, metalness: 0 });
const floor = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), floorMat);
floor.rotation.x = -Math.PI / 2;
floor.position.y = -5; 
floor.receiveShadow = true;
scene.add(floor);

const groundBody = new CANNON.Body({ mass: 0 });
groundBody.addShape(new CANNON.Plane());
groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
groundBody.position.set(0, -5, 0);
world.addBody(groundBody);

// Î≤Ω ÏÉùÏÑ± Î∞è Î∞òÏùëÌòï Ï°∞Ï†ï
let leftWall, rightWall, topWall, bottomWall;

const createWall = (ry) => {
    const wall = new CANNON.Body({ mass: 0 });
    wall.addShape(new CANNON.Plane());
    wall.quaternion.setFromEuler(0, ry, 0);
    world.addBody(wall);
    return wall;
};

rightWall = createWall(-Math.PI/2);
leftWall = createWall(Math.PI/2);
topWall = createWall(Math.PI);
bottomWall = createWall(0);

function updateWalls() {
    const aspect = window.innerWidth / window.innerHeight;
    const xLimit = aspect < 1 ? 3.5 : 7.0; 
    const zLimit = 6.0; 
    rightWall.position.set(xLimit, 0, 0);
    leftWall.position.set(-xLimit, 0, 0);
    topWall.position.set(0, 0, zLimit);
    bottomWall.position.set(0, 0, -zLimit);
}
updateWalls(); 

// 3. Texture
function createDiceTexture(n) {
    const cvs = document.createElement('canvas');
    cvs.width = 512; cvs.height = 512;
    const ctx = cvs.getContext('2d');
    ctx.fillStyle = '#fcfcfc'; ctx.fillRect(0,0,512,512);
    ctx.strokeStyle = '#d0d0d0'; ctx.lineWidth = 15; ctx.strokeRect(0,0,512,512);
    ctx.fillStyle = n===1 ? '#d63031' : '#000000';
    const dot = (x,y) => { ctx.beginPath(); ctx.arc(x,y,45,0,Math.PI*2); ctx.fill(); };
    const p = [128, 256, 384];
    if(n===1) dot(p[1],p[1]);
    if(n===2) { dot(p[0],p[0]); dot(p[2],p[2]); }
    if(n===3) { dot(p[0],p[0]); dot(p[1],p[1]); dot(p[2],p[2]); }
    if(n===4) { dot(p[0],p[0]); dot(p[2],p[0]); dot(p[0],p[2]); dot(p[2],p[2]); }
    if(n===5) { dot(p[0],p[0]); dot(p[2],p[0]); dot(p[1],p[1]); dot(p[0],p[2]); dot(p[2],p[2]); }
    if(n===6) { dot(p[0],p[0]); dot(p[2],p[0]); dot(p[0],p[1]); dot(p[2],p[1]); dot(p[0],p[2]); dot(p[2],p[2]); }
    const texture = new THREE.CanvasTexture(cvs);
    texture.wrapS = THREE.ClampToEdgeWrapping;
    texture.wrapT = THREE.ClampToEdgeWrapping;
    texture.minFilter = THREE.LinearFilter;
    return new THREE.MeshStandardMaterial({ map: texture, roughness: 0.2, metalness: 0.0 });
}

// [ÏàòÏ†ï] Ï£ºÏÇ¨ÏúÑ ÌÅ¨Í∏∞ Ï∂ïÏÜå (1.2 -> 1.0)
const diceGeo = new RoundedBoxGeometry(0.9, 0.9, 0.9, 4, 0.15);
const diceMats = [1,2,3,4,5,6].map(n => createDiceTexture(n));

// 4. Hero Dice
const heroDice = new THREE.Mesh(diceGeo, diceMats);
heroDice.scale.set(1.35, 1.35, 1.35);
heroDice.position.set(0, 0, 0); 
heroDice.castShadow = false;
scene.add(heroDice);

// 5. Game Dice
const gameDiceMeshes = [];
const gameDiceBodies = [];
for(let i=0; i<6; i++){
    const mesh = new THREE.Mesh(diceGeo, diceMats);
    mesh.castShadow = true;
    mesh.visible = false;
    scene.add(mesh);
    gameDiceMeshes.push(mesh);
    
    // [ÏàòÏ†ï] Î¨ºÎ¶¨ Î∞ïÏä§ ÌÅ¨Í∏∞ÎèÑ Ï∂ïÏÜå (0.6 -> 0.5)
    const body = new CANNON.Body({
        mass: 5, shape: new CANNON.Box(new CANNON.Vec3(0.5,0.5,0.5)),
        linearDamping: 0.3, angularDamping: 0.3,
        sleepSpeedLimit: 0.5, sleepTimeLimit: 0.5
    });
    body.position.set(0, -20, 0); 
    body.sleep();
    world.addBody(body);
    gameDiceBodies.push(body);
}

// 6. UI Render Helper
function renderMiniDice(container, value) {
    container.innerHTML = '';
    container.className = `mini-dice ${value === 1 ? 'red' : ''}`;
    const dotMap = { 1: [4], 2: [0,8], 3: [0,4,8], 4: [0,2,6,8], 5: [0,2,4,6,8], 6: [0,2,3,5,6,8] };
    const dots = dotMap[value];
    for(let i=0; i<9; i++) {
        const span = document.createElement('span');
        if(dots.includes(i)) span.className = 'dot';
        container.appendChild(span);
    }
}

// 7. Î°úÏßÅ
window.startGame = () => {
    isHomeMode = false;
    document.getElementById('home-ui').classList.remove('visible');
    document.getElementById('home-ui').classList.add('hidden');
    heroDice.visible = false;
    gameDiceMeshes.forEach(m => m.visible = true);

    const startPos = camera.position.clone();
    const targetPos = new THREE.Vector3(0, 20, 10); 
    let start = null;
    
    function moveCamera(timestamp) {
        if (!start) start = timestamp;
        let progress = (timestamp - start) / 1000;
        if (progress > 1) progress = 1;
        const ease = progress < .5 ? 2 * progress * progress : -1 + (4 - 2 * progress) * progress;
        
        camera.position.lerpVectors(startPos, targetPos, ease);
        camera.lookAt(0, 0, 0); 

        if (progress < 1) requestAnimationFrame(moveCamera);
        else rollLogic();
    }
    requestAnimationFrame(moveCamera);
};

// 8. Ï£ºÏÇ¨ÏúÑ Íµ¥Î¶¨Í∏∞
function rollLogic() {
    isRolling = true;
    stableFrames = 0;
    document.getElementById('status-msg').classList.add('show');
    
    updateWalls();

    gameDiceBodies.forEach(b => {
        b.wakeUp();
        const aspect = window.innerWidth / window.innerHeight;
        const spawnRangeX = aspect < 1 ? 2.0 : 4.0;

        b.position.set((Math.random()-0.5) * spawnRangeX, 5 + Math.random() * 5, (Math.random()-0.5)*5);
        b.velocity.set( (Math.random()-0.5)*10, 5, (Math.random()-0.5)*10 );
        b.angularVelocity.set( Math.random()*20, Math.random()*20, Math.random()*20 );
    });
}

function checkDiceStatus() {
    if (!isRolling) return;
    let totalKineticEnergy = 0;
    gameDiceBodies.forEach(b => {
        totalKineticEnergy += b.velocity.lengthSquared() + b.angularVelocity.lengthSquared();
    });
    
    if (totalKineticEnergy < 0.05) stableFrames++;
    else stableFrames = 0;

    if (stableFrames > 40) { 
        isRolling = false;
        document.getElementById('status-msg').classList.remove('show');
        calculateResult();
    }
}

function calculateResult() {
    let results = [];
    let total = 0;
    gameDiceBodies.forEach((b, i) => {
        b.sleep();
        const directions = [
            { vec: new THREE.Vector3(1, 0, 0), val: 1 },
            { vec: new THREE.Vector3(-1, 0, 0), val: 2 },
            { vec: new THREE.Vector3(0, 1, 0), val: 3 },
            { vec: new THREE.Vector3(0, -1, 0), val: 4 },
            { vec: new THREE.Vector3(0, 0, 1), val: 5 },
            { vec: new THREE.Vector3(0, 0, -1), val: 6 }
        ];
        
        let maxDot = -Infinity;
        let finalVal = 1;
        const worldUp = new THREE.Vector3(0, 1, 0); 

        directions.forEach(dir => {
            const worldDir = dir.vec.clone().applyQuaternion(gameDiceMeshes[i].quaternion);
            const dot = worldDir.dot(worldUp);
            if (dot > maxDot) {
                maxDot = dot;
                finalVal = dir.val;
            }
        });
        results.push(finalVal);
        total += finalVal;
    });

    results.sort((a, b) => a - b);
    let finalScore = Math.round((Math.round(total / 36 * 100) / 100) * 100);

    const grid = document.getElementById('diceGrid');
    grid.innerHTML = '';
    results.forEach(num => {
        const div = document.createElement('div');
        renderMiniDice(div, num);
        grid.appendChild(div);
    });
    
    document.getElementById('totalScore').innerText = finalScore + "Ï†ê";
    document.getElementById('result-ui').classList.remove('hidden');
    document.getElementById('result-ui').classList.add('visible');
}

window.reRoll = () => {
    document.getElementById('result-ui').classList.remove('visible');
    document.getElementById('result-ui').classList.add('hidden');
    setTimeout(rollLogic, 300);
};

window.goHome = () => {
    isHomeMode = true;
    document.getElementById('result-ui').classList.remove('visible');
    document.getElementById('result-ui').classList.add('hidden');
    
    camera.position.set(0, 0, 14);
    camera.lookAt(0, 0, 0);
    
    gameDiceMeshes.forEach(m => m.visible = false);
    gameDiceBodies.forEach(b => { b.position.set(0,-20,0); b.sleep(); });
    heroDice.visible = true;
    
    document.getElementById('home-ui').classList.remove('hidden');
    document.getElementById('home-ui').classList.add('visible');
};

function animate(time) {
    requestAnimationFrame(animate);

    if (isHomeMode) {
        heroDice.rotation.y += 0.01;
        heroDice.rotation.x += 0.005;
        heroDice.position.y = Math.sin(time * 0.002) * 0.3;
    } else {
        world.fixedStep();
        for(let i=0; i<6; i++){
            gameDiceMeshes[i].position.copy(gameDiceBodies[i].position);
            gameDiceMeshes[i].quaternion.copy(gameDiceBodies[i].quaternion);
        }
        if (isRolling) checkDiceStatus();
    }
    renderer.render(scene, camera);
}
animate(0);

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    updateWalls();
});
</script>
</body>
</html>
